/*
 * generated by Xtext 2.37.0
 */
package gameOfLife.model.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import gameOfLife.model.gameOfLife.Model

class GDSLGenerator extends AbstractGenerator {

    override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
        resource.allContents.toIterable.filter(Model).forEach[model |
            fsa.generateFile("RulesOfLife.java", generateRulesOfLife(model))
        ]
    }

    def CharSequence generateRulesOfLife(Model model) '''
        package org.example;

        import java.util.HashSet;
        import java.util.Set;

        public class RulesOfLife {

            private Set<Cell> aliveCells = new HashSet<>();

            public RulesOfLife() {
                initializeGrid();
            }

            private void initializeGrid() {
                «FOR cell : model.cells»
                aliveCells.add(new Cell(«cell.x», «cell.y»));
                «ENDFOR»
            }

            public void nextGeneration() {
                Set<Cell> newAliveCells = new HashSet<>();
                Set<Cell> potentialCells = new HashSet<>(aliveCells);

                for (Cell cell : aliveCells) {
                    potentialCells.addAll(cell.getNeighbors());
                }

                for (Cell cell : potentialCells) {
                    int liveNeighbors = countLiveNeighbors(cell);
                    if (isAlive(cell)) {
                        «FOR rule : model.rules»
                        if (liveNeighbors «rule.condition.operator» «rule.condition.value») {
                            if ("die".equals("«rule.action»")) {
                                // Cell dies
                            } else if ("live".equals("«rule.action»")) {
                                newAliveCells.add(cell);
                            }
                        }
                        «ENDFOR»
                    } else {
                        «FOR rule : model.rules»
                        if (liveNeighbors «rule.condition.operator» «rule.condition.value») {
                            if ("becomeAlive".equals("«rule.action»")) {
                                newAliveCells.add(cell);
                            }
                        }
                        «ENDFOR»
                    }
                }

                aliveCells = newAliveCells;
            }

            private int countLiveNeighbors(Cell cell) {
                int count = 0;
                for (Cell neighbor : cell.getNeighbors()) {
                    if (isAlive(neighbor)) {
                        count++;
                    }
                }
                return count;
            }

            private boolean isAlive(Cell cell) {
                return aliveCells.contains(cell);
            }

            private static class Cell {
                private final int x;
                private final int y;

                Cell(int x, int y) {
                    this.x = x;
                    this.y = y;
                }

                Set<Cell> getNeighbors() {
                    Set<Cell> neighbors = new HashSet<>();
                    for (int dx = -1; dx <= 1; dx++) {
                        for (int dy = -1; dy <= 1; dy++) {
                            if (dx != 0 || dy != 0) {
                                neighbors.add(new Cell(x + dx, y + dy));
                            }
                        }
                    }
                    return neighbors;
                }

                @Override
                public boolean equals(Object o) {
                    if (this == o) return true;
                    if (o == null || getClass() != o.getClass()) return false;
                    Cell cell = (Cell) o;
                    return x == cell.x && y == cell.y;
                }

                @Override
                public int hashCode() {
                    return Objects.hash(x, y);
                }
            }
        }
    '''
}